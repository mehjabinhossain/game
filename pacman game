#include <GL/glut.h>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <string>
#include <iostream>
#include <cmath>

using namespace std;

const int WIDTH = 600, HEIGHT = 600; // game windowr size eta
const int ROWS = 20, COLS = 20; // maze
const int TILE = WIDTH / COLS;

int maze[ROWS][COLS]; // map korar jnno
int pacX = 1, pacY = 1; // pacman er shurute position
int dirX = 0, dirY = 0;
int score = 0, lives = 3;
int level = 1;

bool showMessage = false;
int messageTimer = 0;
string funnyMessage = "Oops! Ghost got you! ðŸ˜‚";

struct Ghost {
int x, y; // ghost er starting coordinate
int dx, dy; // movement koi jabe
float r, g, b;
};
vector<Ghost> ghosts;

struct Bonus {
int x, y;
bool active;
};
vector<Bonus> bonuses;

bool powerUpActive = false; // power khainai tai false
int powerUpTimer = 0;
int flashTimer = 0;

const double PI = 3.14159265358979323846;// circle jatiyo kichu draw er jnnno

// --------- Maze Patterns ----------
void initMaze(int lvl) {
for(int i=0;i<ROWS;i++) // row er jnno 0-19
for(int j=0;j<COLS;j++) // column er jnno
maze[i][j] = 0;

// Borders
for(int i=0;i<ROWS;i++){
maze[i][0] = maze[i][COLS-1] = 1;// 0-1 hoile left edge wall
}
for(int j=0;j<COLS;j++){
maze[0][j] = maze[ROWS-1][j] = 1; //0-1 top edge banai
}

// Different patterns per level
if(lvl==1){
for(int i=5;i<15;i++) maze[5][i]=1;// hori wall row 5 c(5-14)
for(int i=1;i<12;i++) maze[10][i]=1;
}else if(lvl==2){
for(int i=3;i<17;i+=2) maze[3][i]=maze[15][i]=1;
for(int i=4;i<15;i+=2) maze[i][7]=1;
}else if(lvl==3){
for(int i=2;i<18;i++) maze[2][i]=maze[17][i]=1;
for(int i=5;i<15;i++) maze[i][10]=1;
}else if(lvl==4){
for(int i=1;i<19;i+=2) maze[6][i]=maze[13][i]=1;
for(int i=3;i<16;i+=2) maze[i][5]=maze[i][14]=1;
}else if(lvl==5){
for(int i=0;i<COLS;i+=2) maze[4][i]=maze[15][i]=1;
for(int i=5;i<15;i++) maze[i][8]=maze[i][12]=1;
}

pacX = 1; pacY = 1; // pacman er shurur position
dirX = dirY = 0;
}
// --------- Bonuses ----------
void initBonuses() {
bonuses.clear();
int count = 0;
while(count < 5){
int bx = rand() % (COLS-2) + 1; //oouter wall bade bonus place kore
int by = rand() % (ROWS-2) + 1;
if(maze[by][bx] == 0){
bonuses.push_back({bx, by, true});
count++;
}
}
}

// --------- Draw Maze ----------
void drawMaze() {
for (int i = 0; i < ROWS; i++) {
for (int j = 0; j < COLS; j++) {
if (maze[i][j] == 1) {
glColor3f(0.2, 0.2, 1.0);// colour set blue for blocks
glRectf(j * TILE, i * TILE, (j + 1) * TILE, (i + 1) * TILE);
} else if (maze[i][j] == 0) {
glColor3f(1, 1, 1); //ehite color
glBegin(GL_POLYGON);
glVertex2f(j * TILE + TILE/2 - 2, i * TILE + TILE/2 - 2); //left edge  + moves centre , top edge
glVertex2f(j * TILE + TILE/2 + 2, i * TILE + TILE/2 - 2);
glVertex2f(j * TILE + TILE/2 + 2, i * TILE + TILE/2 + 2);
glVertex2f(j * TILE + TILE/2 - 2, i * TILE + TILE/2 + 2);
glEnd();
}
}
}
}


// --------- Draw Bonuses (Banana Shape) ----------
void drawBonuses() {
for(auto &b: bonuses){ // vector bonus save er reference pathachhe
if(b.active){ // active thakle
int cx = b.x*TILE + TILE/2; //coor x hochhe column posit ar * tile diye left edge
int cy = b.y*TILE + TILE/2;
glColor3f(1.0, 0.9, 0.2); // yellow dise

glBegin(GL_POLYGON);
for(int i=0;i<360;i++){
float rad = i*PI/180;
float x = cos(rad)*10 + cx;
float y = sin(rad)*5 + cy + sin(rad*2)*3; // funny curved banana shape
glVertex2f(x, y);
}
glEnd();
}
}
}

// --------- Draw Pacman ----------
void drawPacman() {
glColor3f(1, 1, 0);// yellow colour
glBegin(GL_TRIANGLE_FAN);
glVertex2f(pacX * TILE + TILE/2, pacY * TILE + TILE/2);//pacman e rpositin
for (int i = 30; i <= 330; i++) {
float rad = i * PI / 180;
glVertex2f(pacX * TILE + TILE/2 + cos(rad) * TILE/2,
pacY * TILE + TILE/2 + sin(rad) * TILE/2);
}
glEnd();

glColor3f(0, 0, 0);
glBegin(GL_POLYGON);
float ex = pacX * TILE + TILE/2 + 5; //centre
float ey = pacY * TILE + TILE/2 - 8;
for (int i = 0; i < 360; i++) {
float rad = i * PI / 180;
glVertex2f(ex + cos(rad) * 3, ey + sin(rad) * 3);
}
glEnd();
}

// --------- Draw Ghost ----------
void drawGhost(Ghost &g) {
int gx = g.x*TILE + TILE/2;// ghost centre posit
int gy = g.y*TILE + TILE/2;

if(powerUpActive){
if(powerUpTimer <= 4 && (powerUpTimer % 2 == 0)){
glColor3f(1, 1, 1);//sada
}else{
glColor3f(0, 0, 1);//blue
}
}else{
glColor3f(g.r, g.g, g.b);
}

glBegin(GL_POLYGON);// ghost er body shape
for(int i=0;i<180;i++){
float rad = i * PI / 180;
glVertex2f(gx + cos(rad)*TILE/2, gy + sin(rad)*TILE/2);// vertex along semicircle

}
glVertex2f(gx - TILE/2, gy); // flat base of body
glVertex2f(gx + TILE/2, gy);
glEnd();

glColor3f(1,1,1); //white
for(int k=0;k<2;k++){ // ghost er eye
int offset = (k==0?-7:7); // - left, +gight
glBegin(GL_POLYGON);
for(int i=0;i<360;i++){
float rad=i*PI/180;
glVertex2f(gx+offset+cos(rad)*5, gy-5+sin(rad)*5); // hori eye down 5 unit
}
glEnd();
glColor3f(0,0,0);// black
glBegin(GL_POLYGON);
for(int i=0;i<360;i++){
float rad=i*PI/180;
glVertex2f(gx+offset+cos(rad)*2, gy-5+sin(rad)*2);
}
glEnd();
if(!powerUpActive) glColor3f(g.r,g.g,g.b);
}
}

// --------- Pacman Movement ----------
void movePacman() {
int nx = pacX + dirX;// new cordinate pacmna er
int ny = pacY + dirY;
if (maze[ny][nx] != 1) { // wall thakle no
pacX = nx;
pacY = ny;
if (maze[ny][nx] == 0) {
maze[ny][nx] = -1;  // khabar kheye felse
score += 10;
}

for(auto &b: bonuses){
if(b.active && pacX == b.x && pacY == b.y){// kheye felse
b.active = false;
powerUpActive = true;
powerUpTimer = 50; // 10 seconds
}
}
}
}

// --------- Ghost Movement ----------
void moveGhosts() {
for (auto &g : ghosts) {//loop e choltese
int nx = g.x + g.dx;
int ny = g.y + g.dy;
if (maze[ny][nx] != 1) {
g.x = nx; g.y = ny;
} else {
int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};// jdi wall pay
int r = rand() % 4;
g.dx = dirs[r][0]; g.dy = dirs[r][1];// randomly new directecio
}
}
}

// --------- Collision Check ----------
void checkCollision() {
for(auto &g: ghosts){
if(pacX==g.x && pacY==g.y){// chk packman ghst postin
if(powerUpActive){
score += 50;
g.x = 10; g.y = 10;//erset ghost positin
}else{
lives--;
pacX = 1; pacY = 1;
dirX = dirY = 0;
showMessage = true;
messageTimer = 5;

level = 1;
initMaze(level);
initBonuses();
ghosts.clear();
ghosts.push_back({10,10,1,0,1,0,0});
ghosts.push_back({15,15,0,1,1,0.4,0.7});
ghosts.push_back({10,15,-1,0,0,1,1});
ghosts.push_back({15,10,0,-1,1,0.5,0});

if(lives<=0){
cout<<"Game Over! Final Score: "<<score<<endl;
exit(0);
}
}
}
}
}

// --------- Level Completion ----------
bool levelComplete() {
for(int i=0;i<ROWS;i++)
for(int j=0;j<COLS;j++)
if(maze[i][j]==0) return false;
return true;
}

// --------- Display ----------
void display() {
glClear(GL_COLOR_BUFFER_BIT);
drawMaze();
drawBonuses();
drawPacman();
for (auto &g : ghosts) drawGhost(g);

string hud = "Score: " + to_string(score) + " Lives: " + to_string(lives) + " Level: " + to_string(level);
glColor3f(1,1,1);
glRasterPos2f(10, HEIGHT-20);
for(char c:hud) glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, c);

if(showMessage){
glColor3f(1, 0, 0);
glRasterPos2f(WIDTH/4, HEIGHT/2);
for(char c:funnyMessage) glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, c);
}

glutSwapBuffers();
}

// --------- Timer ----------
void timer(int = 0) {
if(!showMessage){
movePacman();
moveGhosts();
checkCollision();
if(powerUpActive){
powerUpTimer--;
if(powerUpTimer <= 0) powerUpActive=false;
}
} else {
messageTimer--;
if(messageTimer <= 0) showMessage = false;
}

if(levelComplete() && !showMessage){
level++;
if(level > 5){
cout << "You Win! Final Score: " << score << endl;
exit(0);
}
initMaze(level);
initBonuses();
ghosts.clear();
ghosts.push_back({10, 10, 1, 0, 1, 0, 0});
ghosts.push_back({15, 15, 0, 1, 1, 0.4, 0.7});
ghosts.push_back({10, 15, -1, 0, 0, 1, 1});
ghosts.push_back({15, 10, 0, -1, 1, 0.5, 0});
}

glutPostRedisplay();
glutTimerFunc(200, timer, 0);
}

// --------- Keyboard ----------
void keyboard(int key, int, int) {
if(key==GLUT_KEY_LEFT){dirX=-1; dirY=0;}
if(key==GLUT_KEY_RIGHT){dirX=1; dirY=0;}
if(key==GLUT_KEY_UP){dirX=0; dirY=-1;}
if(key==GLUT_KEY_DOWN){dirX=0; dirY=1;}
}

// --------- Main ----------
int main(int argc, char** argv){
srand(time(0));
initMaze(level);
initBonuses();

ghosts.push_back({10,10,1,0,1,0,0});
ghosts.push_back({15,15,0,1,1,0.4,0.7});
ghosts.push_back({10,15,-1,0,0,1,1});
ghosts.push_back({15,10,0,-1,1,0.5,0});

glutInit(&argc, argv);
glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
glutInitWindowSize(WIDTH, HEIGHT);
glutCreateWindow("Pac-Man Game");

glMatrixMode(GL_PROJECTION);
glLoadIdentity();
gluOrtho2D(0, WIDTH, HEIGHT, 0);

glutDisplayFunc(display);
glutSpecialFunc(keyboard);
timer();

glutMainLoop();
return 0;
}






